 Дерево сначала сортируется        по хэш-коду . Если хэш-коды одинаковы, он использует метод compareTo для Comparable, если объекты реализуют этот интерфейс, иначе хэш-код идентификатора .
 Если записи удалены с карты, количество записей в ведре может уменьшиться, так что эта древовидная структура больше не нужна . Для чего нужен UNTREEIFY_THRESHOLD =6 .
 Если количество элементов в ковше опускается ниже шести, мы также можем вернуться к использованию связанного списка .
 Наконец, есть MIN_TREEIFY_CAPACITY =64 .
 Когда хеш-карта растет в размерах, она автоматически изменяет размеры, чтобы иметь больше ковшей .  Если у нас есть небольшая карта хэша, вероятность того, что мы получим очень полные ведра, достаточно высока, потому что у нас нет того, у кого есть много разных ведер, чтобы вставлять вещи .
 Это намного лучше иметь большую карту хеша, с большим количеством ведер, которые менее полны . Эта константа в основном говорит о том, чтобы не начинать делать ведра на деревья, если наша хэш-карта очень мала - вместо этого она должна быть больше размера .
 Чтобы ответить на вопрос об увеличении производительности, эти оптимизации были добавлены для улучшения наихудшего случая . Я только размышляю, но вы, вероятно, только увидите заметное улучшение производительности из-за этих оптимизаций, если ваша функция hashCode была не очень хороша .